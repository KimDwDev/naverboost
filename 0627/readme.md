

# 공부

1. 우리가 문자형태로 코드를 작성하면 렉서가 주석, 공백등을 무시하고 읽으면서 토큰으로 변화 시켜준다.

2. 토큰을 파서가 AST, 등으로 형태로 변화를 시켜준다. 

3. LL, LL(k).. 등등은 파서가 토큰을 읽는 문법의 종류를 뜻한다.

4. 파싱을 한 후 semantic analysis(의미 분석)을 통해 의미가 맞는지 파악하는 단계이다.
  ex: int a = 1;
      printf("%d", b); 
  -> 문법적으로는 한줄 한줄 다 맞다 허나 printf("%d", b)에서 b가 정해지지 않기 때문에 의미는 잘못된것이다. 

5. 의미분석을 한 후 컴퓨터가 이해할 수 있게 lowering 작업을 실시해준다.

  -> High-level -> mid-level -> low-level - target code emission (이러한 단계로 읽을 수 있게 해준다.)

6. 큰 프로젝트의 경우 수백만 줄의 코드가 있을거고 그에 대한 컴파일러 속도를 빠르게 하는 방법에 대해서 고민해야 한다.

7. 과거에 비해 메모리도 커지고 있기 때문에 메모리의 크기도 중요하지만 메모리의 효율성을 따지는게 매우
중요해 졌다.

  -> 캐싱, 다이나믹프로그래밍등 메모리를 사용하더라도 빠른 속도를 위해서 효율적으로 사용하게 하는게 
  중요하다.

  -> 소스코드를 읽을때 캐시 메모리 없이 바로 디스크 읽기에 들어가면 지연이 들어가는데 이걸 메모리를 
  이용해서 읽으면 속도를 향상시킬수 있다.

8. 페이지 캐싱 
  
  -> 수정: 페이지의 변화가 있으면 갱신한다.
  -> 삭제: 페이지의 크기가 작아지면 무효화 하고 삭제 
  -> 추가: 페이지의 크기가 커지면 다음 읽기 시점의 로드
  -> 읽기: 최신 캐시 또는 디스크 내용을 일관성 있게 제공

9. 파서가 인덱스 엑세스를 할 때는 우리가 map해싱을 하는거라고 생각하면 된다 마찬가지로 토큰을 읽을때도 인덱스 액세스를 통해 
  시간 복잡도가 거의 o(1)으로 빠르다.

10. 파서가 토큰을 읽을때 더 빠르게 읽기 위해서는 토큰의 형식또한 중요

11. Carbon_symbol 토큰 
   
   -> Carbon 소스에 나오는 연산자나 구분자 같은 기호를 뜻함 (  +, -, *, /, (), {} ... )
   -> 가장 긴 기호 시퀀스를 하난의 토큰으로 인식 ( >= 이 있으면 >읽고 = 를 읽는게 아닌 >=를 하나의 토큰으로 )
   -> 공백 규칙을 통해 만약 구분하고 싶은게 있다면 공백이 있어야 한다. "a1" 로 인식하는냐 a 1 이렇게 하느냐에 따라서 두개는 뜻이 아예 다르다.

12. 만들어진 AST를 후위, 전위, 중위 순회중 어는 것이 가장 좋을진 고민해야 한다. 

  -> 부모를 파악하고자 할 때는 후위순회가 좋고 선언수집(함수, 변수, 타입을 알아야할 때)는 전위 순회가 좋다.

13. 파서가 토큰을 해석할때도 파서트리를 잘 형성해야 한다.

14. 메타프로그래밍은 프로그램이 프로그램을 다루는 모든 기법의 총칭을 뜻한다.

15. 런타임 기계어로 변형된 다음 실행이 될때의 시간이고 컴파일은 그 기계어로 변환하는 모든 과정을 말한다.

16. 파서 트리에서 후위순회가 좋은 이유는 
  -> a + b * c 를 abc*+ 임으로 a -> bc -> * = > + 이기 때문에 해석상 정말 편하다.
  -> 바텀업 파서(LR)같이 토큰을 쌓아가다 축소하는 방식은 자식을 먼저 만들고 부모로 하기 때문에 후위순회가 좋다.

17. 프런트, 미들, 백로 나누어서 소스코드는 기계어가 되는데 

  -> 프런트: 렉서 -> 파서 -> AST 의미분석 -> IR CODE
  -> 미들: IR CODE 분석 최적화 ( LLVM이 사용 )
  -> 백: IR CODE -> 기계어 변환

18. LLVM은 프런트엔드에서 만든 IRCODE를 최적화 시켜주는 작업을 한다.

19. 자바스크립트는 인터프리터임으로 컴파일러에 추가적인 공부를 진행해야 한다.

20. replace( 문항1, 문항2 ) -> 문항1을 문항 2로 바꾸어 준다.

21. javascipt에서 함수의 결과를 key로 쓰고 싶거나 하면 []안에 다가 쓰면 키값으로 쓸수 있다.

22. formal grammer를 이용해서 파싱을 한다. (N, T, P...)

23. Chomsky의 이론을 가지고 문법을 나누는걸 생각해 냈다.

24. 우리가 만드려는 AST는 토큰을 가지고 만드는 건데 어떻게 해석할지를 알기 위해서 Chomsky이론이 필요하다.

# 의문 

1. 어떻게 의미를 파악하고 여러 가능성이 있는 문자를 파악한다는것인가.... 
  -> parser tree를 각각의 맞게 분석한다.

2. garbage corrector를 이용해서 중간에 데이터를 수집할 수 있다.

3. 컴파일러 속도를 빠르게 하려면 어떻게 해야할까?

4. 그렇다면 컴파일러 속도까지 고려한다면 문자를 최소화하는 것도 속도를 높이는데 도움이 될것이다.

5. memory를 늘린다는건 무엇을 의미하는 걸까?

6. 오토마타 이론은 뭐지?

7. 메모리 캐싱에 대해서 자세히 알아보자ㄴ

8. 토큰에도 여러 종류가 있는것 같은데 그 토큰의 종류에 대해서 생각해 보자

9. 솔직히 파서 트리가 잘이해는 안간다.

10. 메타 프로그래밍이 뭐지?
  
  -> 예를 들어서 코드가 작동하도록 할때 원래라면 정석적으로 작동해야 하는것이 이 메타를 이용해서 
     바뀌는것 

11. 런타임, 컴파일 타임에 대해서 공부

12. LLVM이 뭘까? 

13. 영상을 천천히 봤지만 이해가 안가는 부분이 너무 많다 그러한 부분은 어떻게 처리할지 고민해보자

14. 여러 자료를 봤는데 머리에 잘 안들어온다 기본적인거를 먼저 이해하는게 우선이라고 생각한다.

15. 