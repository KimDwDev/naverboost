# 조건

1. 특정 조건에 맞는 도서를 검색한다.

2. 주어진 데이터는 책이름, 절판여부, 분류, 별점, 권수가 있는 책의 정보와 책의 판매기간을 담은 데이터가 주어진다.

3. 조건에 맞는 책을 찾아라
  - 구매 희망 권수 이상인 도서
  - 조회 시점이 해당 도서의 판매 기간에 포함되는 경우

4. 조건에 맞게 출력값을 내뱉어라
  - 절판된 도서에는 이름 뒤에 *를 붙여서 표시
  - 조건을 전혀 만족하는 도서가 없으면 !EMPTY 반환
  - 별점 내림차순으로 정렬
  - 여러 권이 있을 경우 , 로 구분하여 출력

# 고민

1. 이 문제는 나에게 무슨 능력을 향상시키게 하려는 걸까? 읽어보니 데이터를 어떻게 선언하고 저장할 것인지?
그리고 그 방법이 과연 타당한지? 
-> 데이터를 어떻게 선언할지 고민해보자. 

2. 왜 판매기간과 도서를 나누어 났을까? 두개의 성분이 다른것 같지는 않은데 아... 생각해 보니 두개는 뭔가 의미가 다르긴해 
일단 분리하고 만약 해당 인덱스 위치가 아니라면 어떻게 처리할지를 고민해보자 
-> 너무 딥하게 고민하고 있나? 

3. DB에서 두 데이터를 연결할때 join을 쓰는것 처럼 처음에는 년도를 찾고 그에 맞는 데이터를 찾는 방향으로 고민해보자.

4. 탐색방법에 대해서 고민해보자 정렬 후 이분 탐색 or 완전 탐색 n이 작을때는 완전탐색이 나을지 몰라도 크면 
문제가 생길거야 작을때는 애초에 정렬후 이분탐색도 문제가 딱히 없으니까 정렬후 이분 탐색으로 가자
-> 아니야 정렬하는데 nlogn이 쓰이고 완전 탐색은 n이 잖아 그러면 완전탐색으로 충분한거지

5. 의문점1 
-> 문자열 데이터 바로 파싱하는 방법이 있을지도 몰라 생각을 한번 해보자 
-> 일단은 문자열을 파싱을 하고 그담에 대입하는것은 같기 때문에 일단 이렇게 가보자... 

6. 책을 찾고 데이터를 찾아야 해 아까는 값이 하나라서 완전탐색으로 충분했는데 만약 책이 여러권 이라면? 최악의 경우 n^2이 나올거야 
이경우는 정렬을 한 후 이진탐색을 통해 시간을 아끼는게 좋겠어.

7. 내가 찾은 책을 탐색하면서 영리하게 정렬하는 방법이 뭘까? 고민좀 해봐야겠어.
-> 이미 인덱스 정렬에서 시간복잡도가 nlogn이기 때문에 여기서 줄인다고 드라마틱해 지지는 않아 일단 구현 하고 생각하자 
-> 대신에 정렬은 맨 뒤에 실행함으로서 일단 이득을 보고 나중에 고민을 해보자.

# 공부

1. new Date();는 Date 생성자로 조건이 없다면 자동으로 현재 시간을 알려준다.

2. Date().getFullYear();, Date().getMonth()는 각각 년도와 월을 꺼내온다.

3. ParseInt()는 01이든 1이든 모두 정수로 변환을 해준다.

4. slice를 사용하면 배열에 원하는 부분까지 가져올 수 있다.(문자 동일)

5. new Date(year, month, day ...) 
  -> 년, 월, 일을 넣어서 시간 데이터로 작성이 가능핟.

6. javasript에서는 문자열 끼리 부등호를 통해서 순서를 비교할 수 있다. (자동으로 utf-16을 기준으로 값을 비교한다고 한다.)

7. 정수/정수 한 후 parseInt하면 몫만 구할 수 있다. 
-> 하지만 위험함으로 Math.trunc로 버림할 수 있다.

8. javascript에서도 배열의 주소 기능을 이용 할 수 있다. 따라서 메모리를 증가하지 않고 해당 값을 변화시키는 방법도 항상 고려하자.

9. join할때 한 배열을 정렬하고 이진탐색을 하든 해쉬 탐색을 하든 한다. 

# 실수 

1. new Date()에 들어가는 월 데이터는 0 ~ 11의 숫자여야 한다.

2. if (targetIdx) 부분에서 targetIdx가 0일때 나는 0일떄의 값을 가져와야 하는데 이렇게 되면 애초에 실행을 안하기때문에 
조심하자 javasript는 undefined, Nan, false등 여러 구분자가 있으니까 잘 생각해야 한다.

# 해결

1. 데이터 파싱
  
  - 배열1: Libarary(책 정보)를 " "을 기준으로 나눠서 저장
  - 배열2: BookYear(판매 기간)를 " "을 기준으로 나눠서 저장 

2. 배열2이 포함되는 책 이름만 추출 (문자열로 된 시작·종료 연월을 파싱 → Date 객체로 변환 → 범위 검사)

3. 책 정보 인덱싱 및 검색
  
  - 책 제목과 원본 배열 인덱스를 쌍으로 묶어 새 배열 생성
  - 제목 기준으로 정렬 → 이진 탐색으로 위 2단계에서 찾은 이름의 원본 인덱스 획득

4. 수량·절판 여부 필터링

  - param1(구매 희망 권수) 이상인 항목만 선별
  - 절판된 책엔 이름 뒤에 * 추가

5. 최종 결과 구성

  - 남은 후보들을 별점 내림차순으로 정렬
  - "이름*(분류) 별점" 형태로 합쳐서 콤마(, )로 구분
  - 조건에 부합하는 책이 하나도 없으면 !EMPTY 반환


# 추가사항

1. 책이 중복된다면 어떻게 해야 할까?

2. 완전탐색을 하면서 정렬하는 방법이 뭐가 있을까?

3. 클린 코드를 지향

# 개선점 

1. 애초에 데이터를 join했다면 좀더 클린한 코드가 가능했을것 같다.
  -> 초반에 생각을 했음에도 왜 넘어갔는지 너무 아쉽다... 다음에는 조인을 하고 하는 방향을 생각해 봐야 겠다.

  